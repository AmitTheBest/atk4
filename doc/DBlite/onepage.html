<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>DBlite developer documentation</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>DBlite developer documentation</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Romans</span> <span class="surname">Malinovskis</span></h3><tt class="email">&lt;<a href="mailto:romans@adevel.com">romans@adevel.com</a>&gt;</tt></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d0e16">1. Why was DBlite developed in the first place</a></span></dt><dt><span class="chapter"><a href="#d0e71">2. Connecting to database, DSN</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e74">1. Using DBlite::connect</a></span></dt><dt><span class="section"><a href="#d0e112">2. Extending DSN parser</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e127">3. Using regular queries and fetching data</a></span></dt><dd><dl><dt><span class="section"><a href="#assoc">1. Using $assoc argument for getAll and getRow</a></span></dt><dt><span class="section"><a href="#d0e281">2. Error handling</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e298">2.1. Setting up error handler</a></span></dt><dt><span class="section"><a href="#d0e305">2.2. Writing error handler</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e335">4. Introduction to Dynamic SQL</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e458">1. Implementation of Dynamic SQL calls</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e469">5. Extending Dynamic SQL</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e474">1. Adding new query type</a></span></dt><dt><span class="section"><a href="#d0e481">2. Adding new variables in template</a></span></dt><dt><span class="section"><a href="#d0e488">3. New variable types for dsql</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e497">6. Writing your own database driver</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e502">1. Writing a new driver</a></span></dt><dt><span class="section"><a href="#d0e507">2. Updating existing driver or writing set of drivers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#plans">7. Future plans</a></span></dt><dd><dl><dt><span class="section"><a href="#compat">1. Compatibility layers</a></span></dt><dt><span class="section"><a href="#d0e536">2. Generic variable setting functions in DSQL</a></span></dt><dt><span class="section"><a href="#d0e541">3. Batch commands for DSQL</a></span></dt></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e16"></a>Chapter&nbsp;1.&nbsp;Why was DBlite developed in the first place</h2></div></div><div></div></div><p>DBlite aim is to provide similar functionality to PEAR::DB striping off all optional features (such as sequences, PEAR error handling). DBlite provides flexible SQL layer</p><p>On top of that DBlite provides and encourages developer to use Dynamic SQL subsystem, which allows SQL statement built dynamically as a PHP class and converted into database-specific SQL syntax on demand.</p><div class="table"><a name="d0e23"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Features provided by DBlite</b></p><table summary="Features provided by DBlite" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody><tr><td>DSN parsing and handling</td><td>Similar to the way PEAR::DB uses it, DBlite allows you to connect to database by specifying DSN.</td></tr><tr><td>Flexible DSN handling</td><td>PEAR::DB defines strict form how DSN are formatted. DBlite allows plugins to use DSN extentions and re-define DSN parsing function.</td></tr><tr><td>query, data fetching, all-in-one function (getOne)</td><td>DBlite provides only basic functions as a standart. While such features as preparing queries or executing multiple queries are still posible for the database backends which support them, those are not present and not emulated by default. However dynamic SQL subsystem may gain benifits from those extentions provided if provided.</td></tr><tr><td>Error handling</td><td>Error handling relies on debug_backtrace() function and can provide more quality information than PEAR::DB such as the location of the failed query. As a error handler both user defined regular function and object method can be used, which allows user to avoid using static variables or functions.</td></tr><tr><td>Dynamic SQL</td><td>Idea is taken from AModules2 which used dynamic queries. However our implementation provides additional benefits:<div class="itemizedlist"><ul type="disc"><li><p>Ability to use updates, deletes and user-defined query templates</p></li><li><p>When using different database drivers additional function becomes available. For example Oracle backend may implement subselect option for dynamic queries.</p></li><li><p>Dynamic SQL is represented by a class/object, so it's easy to use it.</p></li></ul></div></td></tr></tbody></table></div><p>DBlite is the right choice for the carefuly planed object oriented project or libriary. DBlite is distributed under LGPL.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e71"></a>Chapter&nbsp;2.&nbsp;Connecting to database, DSN</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e74"></a>1.&nbsp;Using DBlite::connect</h2></div></div><div></div></div><p></p><p>DBlite uses the same form of DSN strings as described in PEAR::DB manual:<a href="http://pear.php.net/manual/en/package.database.db.intro-dsn.php" target="_top">http://pear.php.net/manual/en/package.database.db.intro-dsn.php</a></p><p>DBlite converts DSN into key-&gt;value pair hash. If parsing function is unable to use your DSN (might be because of separator characters in username or password) try passing array instead of DSN string. Commonly possible hash keys are like shown below, but depending on database driver they may vary.</p><div class="table"><a name="d0e84"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;DSN hash keys accepted by DBlite::connect</b></p><table summary="DSN hash keys accepted by DBlite::connect" border="1"><colgroup><col><col></colgroup><tbody><tr><td>type</td><td>Database driver name, ie mysql, oracle, mysqli</td></tr><tr><td>hostspec</td><td>Database host</td></tr><tr><td>username</td><td>&nbsp;</td></tr><tr><td>password</td><td>&nbsp;</td></tr><tr><td>port</td><td>Overrides default port when connection to database (currently not supported by mysql)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e112"></a>2.&nbsp;Extending DSN parser</h2></div></div><div></div></div><p>This section is intended for driver developers. To customize syntax of DSN string, you must redefine <tt class="function">parseDSN</tt> function. If you call <tt class="function">parent::parseDSN</tt>, it will pre-parse DSN and return array. You can search for additional things inside DSN and complete array before returning it. You can as well completely replace parent's function.</p><p><tt class="function">DBlite::parseDSN</tt> will also return 'body' argument which is not used by drivers but contains everything between type:// and the last slash. Getting data directly from 'body' might be easier.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e127"></a>Chapter&nbsp;3.&nbsp;Using regular queries and fetching data</h2></div></div><div></div></div><p>While DBlite suggests using dynamic SQL where possible, you can still use regular queries.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Phylosophy of DBlite is not agree with PEAR::DB which emulates some common features if data handler does not support it. We might include such emulation if it does not affect speed, however.</p><p>Since not all databases (such as mysql) supports arguments in a query, we do not emulate them to provide compatibility. However we do plan on using them from Dynamic SQL if driver provides such functionality. This also applies on other things such as query joining, cursors, commits, sequences and limits.</p><p>Perhaps in latter versions we might have compatibility requirements implemented as PHP5 interfaces and advanced classes: compat_mysql ,compat_oracle. If you are interested, read <a href="#plans" title="Chapter&nbsp;7.&nbsp;Future plans">Chapter&nbsp;7, <i>Future plans</i></a></p></div><p>I assume you already understand about queries and pooling data, if not - read PEAR::DB documentation or PHP documentation. Here are the list of functions you can use for queries and fetching data:</p><div class="table"><a name="d0e142"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;using regular queries and fetching data</b></p><table summary="using regular queries and fetching data" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Function name</th><th>Description</th><th>Driver compatibility</th></tr></thead><tbody><tr><td>query($query_string)</td><td>parse and execute query. Results are not fetched.</td><td>C0</td></tr><tr><td>fetchRow()</td><td>return one row from last query.</td><td>C1,mysql</td></tr><tr><td>fetchHash()</td><td>similar to fetchRow</td><td>C1,mysql</td></tr><tr><td>numRows()</td><td>number of rows returned by last query</td><td>C1,mysql</td></tr><tr><td>numCols()</td><td>number of columns returned by last query</td><td>C1,mysql</td></tr><tr><td>affectedRows()</td><td>numbe of rows affected by update/delete or similar queries</td><td>C1,mysql</td></tr><tr><td>lastID()</td><td>ID of last insert as from auto_increment</td><td>C1,mysql</td></tr><tr><td>getAll($query,$assoc)</td><td>execute query and return all results in a two dimensional array. Read <a href="#assoc" title="1.&nbsp;Using $assoc argument for getAll and getRow">Section&nbsp;1, &#8220;Using $assoc argument for getAll and getRow&#8221;</a> about how 2nd argument affects row association.</td><td>C0</td></tr><tr><td>getRow($query,$assoc)</td><td>execute query and return only first row. Read <a href="#assoc" title="1.&nbsp;Using $assoc argument for getAll and getRow">Section&nbsp;1, &#8220;Using $assoc argument for getAll and getRow&#8221;</a></td><td>C0</td></tr><tr><td>getOne($query)</td><td>execute query and return first cell of first row.</td><td>C0</td></tr></tbody></table><table summary="using regular queries and fetching data" border="1"><colgroup><col><col></colgroup><thead><tr><th>Compatibility</th><th>Meaning</th></tr></thead><tbody><tr><td>C0</td><td>Zero level compatibility. Function is supported by all drivers.</td></tr><tr><td>C1</td><td>First level compatibility. compat1_* drivers will either support natively or emulate this function. Read <a href="#compat" title="1.&nbsp;Compatibility layers">Section&nbsp;1, &#8220;Compatibility layers&#8221;</a> for details about compatibility layer.</td></tr><tr><td>mysql, ..</td><td>Drivers implementing function</td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assoc"></a>1.&nbsp;Using $assoc argument for <tt class="function">getAll</tt> and <tt class="function">getRow</tt></h2></div></div><div></div></div><p>Argument values might be:</p><p>0: (zero) returned data will be 2-dimensional array:</p><pre class="screen">$result = array(
 array($row1_col1, $row1_col2),
 array($row2_col1, $row2_col2)
);</pre><p>This feature will work only if database driver supports getRow().</p><p>1: returned data will be array of hashes as returned by getHash():</p><pre class="screen">$result = array(
 array('fld1'=&gt;$row1_col1, 'fld2'=&gt;$row1_col2),
 array('fld1'=&gt;$row2_col1, 'fld2'=&gt;$row2_col2)
);</pre><p>This feature will work only if database driver supports getHash().</p><p>2: returned data will be hash of hashes excluding first column. Instead first column will be used as key for outer hash:</p><pre class="screen">$result = array(
 $row1_col1 =&gt; array('fld2'=&gt;$row1_col2),
 $row2_col1 =&gt; array('fld2'=&gt;$row2_col2),
);</pre><p>This feature depends on getHash()</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e281"></a>2.&nbsp;Error handling</h2></div></div><div></div></div><p>Every library nowdays implements error handling itself. We wanted to create minimalistic error handling code, but rather provide as much information as possible.</p><p>If error occurs during query, DBlite will not return any error strings, but instead it will just return "false". Additionally it will call error-handler before that. It might be unusual to how it's done elsewhere:</p><pre class="screen">...
$result = query();
if(is_error($result)){
  handle_error();
  return false;
}
...</pre><p>Using DBlite it is simpler:</p><pre class="screen">...
if(query()===false)return false;
...</pre><p>Our point is that user should not check for errors everywhere. Even if user does not check return codes application will work as normal and report error if happened:</p><pre class="screen">...
query();
...</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e298"></a>2.1.&nbsp;Setting up error handler</h3></div></div><div></div></div><p>We knew DBlite would be used in object oriented environment, where static functions migth not exist at all. Therefore error handler can call method of the object you give to him. Assign errorr_handler_class and error_handler_method. If you assign just error_handler_method, it will be called as a static function.</p><pre class="screen">class API {
 var $db;
 function error_handler($caller,$str,$info=null){
  ...
 }
 function foo(){
   $this-&gt;db-&gt;error_handler_class =&amp; $this;
   $this-&gt;db-&gt;error_handler_method = 'error_handler';
   if($this-&gt;db-&gt;query("select a from b")===false)return false;
   if($this-&gt;db-&gt;query("update b set a=1")===false)return false;
 }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e305"></a>2.2.&nbsp;Writing error handler</h3></div></div><div></div></div><p>Consider example from the previous section. <tt class="function">error_handler</tt> will receive 3 arguments:</p><div class="glosslist"><dl><dt>$caller</dt><dd><p>Reference to DBlite class. It might be useful since you can pull more information from it, such as username or hostname.</p></dd><dt>$str</dt><dd><p>Error message string. It will be something like "Can't execute query"</p></dd><dt>$info</dt><dd><p>This array contains additional pieces of information which was collected during error. The contents may vary depending on database driver and <tt class="function">error()</tt> implementation. Usually you will receive "error" which is returned by database, "query_str" is a original query (note that even if getRow fails, you will receive "quey_str") and "caller" is a place in your code where you executed query. All this information will be useful for debuging, however it should not be displayed to user for safety reasons.</p></dd></dl></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e335"></a>Chapter&nbsp;4.&nbsp;Introduction to Dynamic SQL</h2></div></div><div></div></div><p>&#8220;<span class="quote">select name,surname,salaries.salary from person left join salaries on salary.person_id=person.id where salaries.salary&gt;123</span>&#8221;</p><p>How does it look? I'd say - too static. That's why we started implementing Dynamic SQL. Here is the code which does the same thing in Dynamic SQL:</p><pre class="screen">$q = $db-&gt;dsql();
$q-&gt;table('person');
$q-&gt;join('salaries','salary.person_id=person.id');
$q-&gt;field(array('name','surname','sallaries'));
$q-&gt;where('salaries.salary&gt;123');
$str = $q-&gt;select();</pre><p>How does DSQL look? I know, it looks like making simple thing more complex. However after some thinking - it is much more flexible. Imagine that we can set additional propertien to the query by calling function:</p><pre class="screen">...
$q-&gt;where('salaries.salary&gt;123');
set_additional_arguments($q);
$str = $q-&gt;select();</pre><p>And you can re-use arguments you have already in $q like the following:</p><pre class="screen">...
$q-&gt;where('salaries.salary&gt;123');
$data=$q-&gt;do_select();
$q-&gt;set('fired="Y"');
$q-&gt;do_update();</pre><p>Here we just re-used arguments from first query in followed "update" query. When you think about re-defining function in oboject-oriented class model, you can dedicate a method creating dynamic SQL, then re-define it to add aditional arguments to a query.</p><p>Or yet another idea - you can have function which pre-creates queries for you for example <tt class="function">get_childs($parent),</tt> which would receive dynamic SQL for child element selection for given $parent. But it gives you flexibility to add additional fields or join tables after query is formed.</p><p>There are a lot of uses for Dynamic SQL especially when you are writing generic library. That's why we included dynamic SQL support into core of DBlite.</p><div class="table"><a name="d0e362"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Dynamic SQL: setting arguments</b></p><table summary="Dynamic SQL: setting arguments" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>function</th><th>description</th><th>compatibility</th></tr></thead><tbody><tr><td>table</td><td>Set main table for query</td><td>C0</td></tr><tr><td>field</td><td>Add field to list of selected fields</td><td>C0</td></tr><tr><td>set</td><td>Set fields to values for update and insert</td><td>C0</td></tr><tr><td>where</td><td>Set where clause for update, delete and update</td><td>C0</td></tr><tr><td>join</td><td>Join with another table.</td><td>C0</td></tr><tr><td>order</td><td>Set order fields</td><td>C0</td></tr></tbody></table></div><div class="table"><a name="d0e417"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;Dynamic SQL: generating queries</b></p><table summary="Dynamic SQL: generating queries" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>function</th><th>description</th><th>compatibility</th></tr></thead><tbody><tr><td>select</td><td>Return corresponding</td><td>C0</td></tr><tr><td>update</td><td>-"-</td><td>C0</td></tr><tr><td>insert</td><td>-"-</td><td>C0</td></tr><tr><td>delete</td><td>-"-</td><td>C0</td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e458"></a>1.&nbsp;Implementation of Dynamic SQL calls</h2></div></div><div></div></div><p>Dynamic SQL is implemented as a generic class defined in DBlite.php. However this class forwards calls to database driver, since it's functionality depends directly on database functions. In PHP5 calls can be forwarded smoothly using __call, __get, __set functions, however for PHP4 we had to create wrapper functions.</p><p>Before you can use Dynamic SQL you should create dsql object by calling $db-&gt;dsql();</p><p>Dynamic SQL object works as a data storage - while all calls forwarded to database driver, data is stored in dsql object. When call such as $q-&gt;where($clause) happens, this variable is only stored in array inside $q.</p><p>Actual query is constructed only when requested by insert/select/delete/update. $q-&gt;insert() will be forwarded to $db-&gt;dsql_insert(), which in turn will execute $db-&gt;dsql_parseTemplate(..). Right, there are query templates in database driver. Template parser will put actual values inside template and return the query string.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e469"></a>Chapter&nbsp;5.&nbsp;Extending Dynamic SQL</h2></div></div><div></div></div><p>Dynamic SQL code is designed to be easily extended by database drivers and it can be extended in several ways.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e474"></a>1.&nbsp;Adding new query type</h2></div></div><div></div></div><p>MySQL supports "replace into.." syntax, while other databases might not support it. For users to be able to use Dynamic SQL with some additional queries you need to create your own driver class (writing database drivers explained in next chapter). Create function dsql_replace(), which would similar to dsql_insert.</p><p>This will allow calling $q-&gt;replace() to generate query from the template you provided in that function.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e481"></a>2.&nbsp;Adding new variables in template</h2></div></div><div></div></div><p>As you customize query types, you may need to use additional variables in your template.</p><p>Template parser will call dsql_getArgs() with list of needed templates. You can redefine dsql_getArgs() to add additional argument support. You will have to pick data from dsql object and generate string from those.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e488"></a>3.&nbsp;New variable types for dsql</h2></div></div><div></div></div><p>When you configure your dsql you set it's variables for template such as fields, table etc. You will need to allow users to provide those.</p><p>Currently you can just add function dsql_newvariable() so that it would record field data. However we plan on making generic variables before 1.0 version. Read more in <a href="#plans" title="Chapter&nbsp;7.&nbsp;Future plans">Chapter&nbsp;7, <i>Future plans</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e497"></a>Chapter&nbsp;6.&nbsp;Writing your own database driver</h2></div></div><div></div></div><p>This chapter covers writing of new driver or extending existing.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e502"></a>1.&nbsp;Writing a new driver</h2></div></div><div></div></div><p>First you should think about handle name for that driver. Then create file DBlite/&lt;handle&gt;.php and describe class DBlite_&lt;handle&gt; in that file. If you inherit from other class than DBlite you will have to include file.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e507"></a>2.&nbsp;Updating existing driver or writing set of drivers</h2></div></div><div></div></div><p>DBlite allows you to override default drivers or even create set of drivers. To do so you will have to place your files as DBlite/&lt;mod&gt;/&lt;handle&gt;.php and the class names would be DBlite_&lt;mod&gt;_&lt;handle&gt;.</p><p>When duing DBlite::connect, providing 2nd optional argument will tell DBlite to use that mod. 2nd argument may be coma separated list of mods which woud be probed before falling back to default drivers.</p><p>Good example of using completely different driver set is C1 compatibility layer implementation (<a href="#compat" title="1.&nbsp;Compatibility layers">Section&nbsp;1, &#8220;Compatibility layers&#8221;</a>).</p><p>Of course you can inherit from either default driver classes or different set, but you have to do file inclusion on your own.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="plans"></a>Chapter&nbsp;7.&nbsp;Future plans</h2></div></div><div></div></div><p>We have several plans for the future.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="compat"></a>1.&nbsp;Compatibility layers</h2></div></div><div></div></div><p>As you might already know after reading this documentation - we are not looking at database independent layer, but we are just providing flexible library for using SQL. If your application is intended to work with MySQL, DBlite provides all mysql features to you. While PEAR::DB encaurages on using sequence emulation on MySQL, DBlite suggests using nextId().</p><p>This does makes library much lighter, but application loose compatibility. Therefore we designed a way to acheive compatibility across different database engines. Actually there are 2 ways - first way is to use Dynamic SQL wich is portable and will use database features to the maximum. Other way to do it is write C1-compliant code.</p><p>C1 is first level of compatibility. C1 provided set of database drivers which includes emulation for missing features. For example feature of "limit" on mysql will be emulated my pooling only set of rows by oracle set of driver.</p><p>Compatibility driver set will be stored in compat1 subdirectory. We might as well build a 2nd level compatibility layer which would do more emulation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e536"></a>2.&nbsp;Generic variable setting functions in DSQL</h2></div></div><div></div></div><p>Currently when you want to set table or field variable custom function (such as dsql_table) called. We plan on making generic version of this system, before function implementation is too similalr.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e541"></a>3.&nbsp;Batch commands for DSQL</h2></div></div><div></div></div><p>Sometimes when dynamic SQL is created and executed inside function is still necessary to have optional control over it from outside the function.</p><p>We plan on making $dsql-&gt;batch() command, which will accept array in form:</p><pre class="screen">array(
 'table'=&gt;'userlist',
 'fields'=&gt;array('name','surname')
);</pre><p>Such an array may be passed inside function using Dynamic SQL and applied on dsql object before execution.</p></div></div></div></body></html>